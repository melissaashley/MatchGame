"use strict";

/**
 * cards - data and duplicate
 */
var cards = ['bomb', 'diamond', 'leaf', 'paper', 'bolt', 'rocket', 'send', 'ghost'];
var gridBoard = cards.concat(cards);
/**
 * DOM elements
 */

var game = document.getElementById('game');
var resetIt = document.getElementById('reset');
var winner = document.getElementById('winner');
var moves = document.getElementById("moves");
var allCards = document.getElementsByClassName('tile');
var allFlipped = document.getElementsByClassName('flipped');
var flippedCards = [];
var count = 0;
var interval;
/**
 * startGame - start the game
 */

var startGame = function startGame() {
  emptyCardsArray();
  stopTimer(); // Clear board

  game.innerHTML = ''; // Shuffle it

  gridBoard.sort(function () {
    return 0.5 - Math.random();
  });
  generateCardBoard(); // Reset 

  count = 0;
  moves.innerHTML = 'Moves: ' + count;
  winner.innerHTML = '';
  winner.classList.remove('won');
  timer.innerHTML = '0 seconds';
  startTimer();
};
/**
 * resetGame - reset the game
 */


resetIt.addEventListener('click', startGame);
/**
 * emptyCard - resets the flippedCards array
 *
 * @param {Array} flippedCards
 */

var emptyCardsArray = function emptyCardsArray() {
  flippedCards = [];
};
/**
 * flipCard - add selected class when selected
 */


var flipCard = function flipCard() {
  if (!this.classList.contains('flipped')) {
    this.classList.add('selected');
  }
};
/**
 * checkMatch - check if the cards match
 */


var checkMatch = function checkMatch() {
  flippedCards.push(this);

  if (flippedCards.length === 1) {
    // Remove the event listener so they can't match the identical card (double click)
    flippedCards[0].removeEventListener('click', checkMatch);
  }

  if (flippedCards.length === 2) {
    if (flippedCards[0].getAttribute('data-type') === flippedCards[1].getAttribute('data-type')) {
      cardsMatch();
    } else {
      cardsDontMatch(); // Add listener back when cards don't match

      flippedCards[0].addEventListener('click', checkMatch);
    }
  }
};
/**
 * cardsMatch - the cards match
 */


var cardsMatch = function cardsMatch() {
  flippedCards[0].classList.add('flipped');
  flippedCards[1].classList.add('flipped'); // Prevents additional moves being tallied once you have flipped the correct cards

  flippedCards[0].removeEventListener('click', checkMatch);
  flippedCards[1].removeEventListener('click', checkMatch);
  addMove();
  removeSelectedAll();
  emptyCardsArray(); // Check if the game was won after the last match

  wonGame();
};
/**
 * cardsDontMatch - the cards do NOT match
 */


var cardsDontMatch = function cardsDontMatch() {
  addMove();
  setTimeout(function () {
    flippedCards[0].classList.remove('selected');
    flippedCards[1].classList.remove('selected');
    removeSelectedAll();
    emptyCardsArray();
  }, 600);
};
/**
 * removeSelectedAll - remove selected from all cards when cards do not match
 * TODO: Handle this better, instead of removing classes prevent the clicks
 */


var removeSelectedAll = function removeSelectedAll() {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = allCards[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var card = _step.value;
      card.classList.remove('selected');
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};
/**
 * wonGame - notification if the user wins the game
 */


var wonGame = function wonGame() {
  var totalCards = 16;

  if (totalCards === allFlipped.length) {
    winner.classList.add('won');
    winner.innerHTML = 'You won the game!';
    window.scrollTo(0, 0);
    stopTimer();
  }
};
/**
 * addMove - update the number of moves
 */


var addMove = function addMove() {
  count += 1;
  moves.innerHTML = 'Moves: ' + count;
};
/**
 * startTimer - start the timer
 */


var startTimer = function startTimer() {
  var second = 0;
  interval = setInterval(function () {
    timer.innerHTML = second + ' seconds';
    second++;
  }, 1000);
};
/**
 * stopTimer - stop the timer
 */


var stopTimer = function stopTimer() {
  clearInterval(interval);
};
/**
 * Generate cards
 * 
 * @param {Object} cards
 */


var generateCardBoard = function generateCardBoard() {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = gridBoard[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var eachCard = _step2.value;
      var card = document.createElement('div');
      card.classList.add('tile', eachCard);
      card.dataset.type = eachCard;
      game.appendChild(card);
      card.addEventListener('click', flipCard);
      card.addEventListener('click', checkMatch);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
};

startGame();
//# sourceMappingURL=app.min.js.map
